### 



### 

# Spring



### Bean的作用域

> - singleton
>
>   默认作用域、单例模式，作用范围是ApplicationContext
>
> - prototype
>
>   一般bean可以有多个实例，被IOC容器管理时没有被实例化
>
> - request、session、application、websocket
>
>   仅作用域与WebApplicationContext环境

### Bean的生命周期

> 实例化 -> 属性赋值 -> 初始化 -> 销毁四个阶段
>
> BeanDefinition
>
> ​		↓			←	postProcessBeforeInstantiation
>
> ​		↓								↑
>
> ​	实例化				InstantiationAwareBeanPostProcessor
>
> ​		↓								↓
>
> ​		↓			←	postProcessAfterInstantiation
>
> 属性赋值					
>
> ​		↓			←	postProcessBeforeInstantiation
>
> ​		↓								↑
>
> ​	初始化				BeanPostProcessor
>
> ​		↓								↓
>
> ​		↓			←	postProcessAfterInstantiation
>
> ​	销毁

### 如何解决跨域问题

> @CrossOrigin 注解、全局配置（WebMvcConfigurer）、Filter
>
> Nginx的反向代理也可以解决

### 为什么不推荐使用@Autowired

> [spring 和 idea 建议不要使用 @Autowired注解的原因解析_java_脚本之家 (jb51.net)](https://www.jb51.net/program/30359847n.htm)



# Java

### volatile关键字的作用，为什么能关闭指令重排序

> #### 实现可见性
>
> 因为不同线程有自己的工作内存区，实现了同一对象的多份拷贝，所以互不可见，需要voliate。基于内存屏障(Memory Barrier)实现
>
> #### volatile 的 happens-before 关系
>
> happens-before 规则中有一条是 volatile 变量规则：对一个 volatile 域的写，happens-before 于任意后续对这个 volatile 域的读。

### 手写一个单例模式

```java
public class singleDemo{
  //懒汉式
  //优点 没有线程安全问题，但是类加载就创建对象，浪费空间
  private final static singleDemo instance = new singleDemo();
  private singleDemo(){};
  public static singleDemo getInstance(){
    return instance;
  }
}
```

```java
public class singleDemo{
    //双重检查懒汉式
    //volatile防止指令重排
    private volatile static singleDemo instance;
    private singleDemo(){};
    public static singleDemo getInstance(){
        if (instance == null){
            synchronized (singleDemo.class){
                //两个线程都走到这时，一个创建完释放锁后防止另一个也创建
                if (instance == null){
                    instance = new singleDemo();
                }
            }
        }
        return instance;
    }
}
```

# 数据库

### MySQL 架构中的三层服务是什么？

> 1.客户端层（连接层）：客户端层是与用户交互的部分，响应请求等，常见的客户端如Navicat、命令行
>
> 2.服务器层：负责接收客户端的请求，解析SQL语句，执行数据库操作，并将结果返回给客户端
>
> 3.存储引擎层：存储引擎层负责数据的存储和管理，是MySQL中数据的物理存储方式

### mysql集群如何搭建，各节点如何通信

> 第一步：在主库中，如果有数据更新，则主库会将数据的事务操作DML记录到二进制日志binary log中（在配置文件中log-bin指定的文件就是日志文件）。
> 第二步：从库会监听主库的binary log日志文件变化，当发生数据变化后，会将主库的日志文件拷贝到它的中继日志（relay log）中，放在末端。I/O线程会不断的去请求主库的bin-log日志，并将日志写入到relay log中，此时主库会生成一个log dump线程，用来给从库I/O线程传输bin-log日志文件。而且会将读取到的Master端的bin-log的文件名和位置记录到master-info文件中，以便在下一次读取的时候能够清楚的告诉Master “我需要从某个bin- log的哪个位置开始往后的日志内容，请发给我”。
> 第三步：从库会更新relay log文件中的操作，将数据的改变在从库中进行数据重演（即SQL线程执行操作，将日志文件中的记录变为数据操作行为再次执行，以达到主从数据最终一致性的目的）。

### 为什么不能使用自增ID或UUID做主键

> 1.存储空间占的更多
>
> 2.由于随机可能索引没有顺序性，导致索引效率低，树深度增加
>
> 3.难以读取和调试

# MQ

### 如果消息队列因为服务器或者网络原因挂了，怎么处理

> 开启消息队列的持久化

### 消息丢了/一致性问题

> [消息队列把消息弄丢了怎么办？-腾讯云开发者社区-腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/1823719)
>
> 1.生产者确认、MQ确认机制
>
> 2.MQ持久化
>
> 3.消费者失败重试

### mq怎么保证消息的顺序性

> 保证一个queue对应一个consumer

### mq的幂等性是什么，如何消除幂等

> 任意多次执行所产生的影响均与一次执行的影响相同
>
> 1.添加版本号（唯一消息`ID`），但是存在业务侵入
>
> 2.利用数据库特性，建立去重表
>
> 3.结合业务逻辑本身判断

# Redis

### redis集群如何搭建，各节点如何通信

> 1.主从集群 2.分片集群
>
> [Redis集群详解（包含搭建）_redis 集群搭建-CSDN博客](https://blog.csdn.net/m0_73774439/article/details/140607001)

### redis集群如何实现负载均衡

> 散列插槽 ？ 轮询、随机等

### 如果热点数据落在redis的某个节点上导致负载均衡失效，该如何解决

> [只需七步，教你轻松解决Redis热点Key问题 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/624724087)
>
> 数据分片（哈希）、读写分离（降低单个节点负载）、缓存预热、限流、熔断

### redis集群如何保持数据一致性

> 全量同步
>
> ​		发送的自己的`replid`和`offset`，如果`replid`不一致则是第一次同步，把内存数据实现RBD，记录在`repl_baklog`，将`log`内容持续发送给从节点
>
> 增量同步
>
> ​	从节点把`repl_baklog`中自己的`offset`发给主节点
>
> 优化：
>
> 1. 在master中配置`repl-diskless-sync yes`启用无磁盘复制，避免全量同步时的磁盘IO
> 2. Redis单节点上的内存占用不要太大，减少RDB导致的过多磁盘IO
> 3. 适当提高`repl_baklog`的大小，发现slave宕机时尽快实现故障恢复，尽可能避免全量同步
> 4. 限制一个master上的slave节点数量，如果实在是太多slave，则可以采用`主-从-从`链式结构，减少master压力

### redis如何保证缓存一致性

> - **低一致性**：
>
>   使用Key的expire过期清理方案
>
> - **高一致性**：
>
>   读操作：命中缓存则直接返回，不命中则将数据库内容写入缓存并设置过期时间
>
>   写操作：Cache Aside Pattern，业务开发者更新数据库同时更新缓存
>
>   ​	先删数据库，后删缓存，尽可能保证查询的数据的时效性，再保险一点可以使用延时双删
>
>   ​	即删除缓存 -> 删除数据库 -> 延时二次删除缓存，保证中间过程有其他数据写入缓存也可以删掉



### 缓存穿透、缓存雪崩、缓存击穿

> **缓存穿透**：指redis和数据库中都没有数据，返回空，而不断请求
>
> - 解决方法：1.缓存NULL值  2.布隆过滤 3.增强参数的格式
>
> **缓存雪崩**：大量的缓存`key`失效（`TTL`过期）或者 `redis`服务器宕机，导致大量请求直接到达数据库带来的压力
>
> - 解决方法：1.TTL后添加一定随机值 2.redis集群 3.限流降级 4.多级缓存
>
> **缓存击穿**：热点key（高并发访问，业务复杂的key）突然失效

# 分布式

### 怎么解决分布式事务

> [遇到分布式事务，这四种方案可以让你眉开眼笑~ - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/678443715)
>
> 本地消息表+重试：将分布式事务拆分成本地事务，新建消息表，保证消息的消费和DB的消费在一个事务内
>
> seata的AT模式，事务提交后增加一个快照(undo log)，
>
> 一阶段提交和报告事务状态，二阶段提交并删除undolog或者回滚

### 

### 分布式锁的实现

> 1.利用redis的setnx并且需要用lua脚本保证原子性

# 高并发

### 高并发情况下如何优化系统（外部、系统、底层等多个角度）

> 
### 



### 

# Spring

# Java

### volatile关键字的作用，为什么能关闭指令重排序

> #### 实现可见性
>
> 因为不同线程有自己的工作内存区，实现了同一对象的多份拷贝，所以互不可见，需要voliate。基于内存屏障(Memory Barrier)实现
>
> #### volatile 的 happens-before 关系
>
> happens-before 规则中有一条是 volatile 变量规则：对一个 volatile 域的写，happens-before 于任意后续对这个 volatile 域的读。

### 手写一个单例模式

```java
public class singleDemo{
  //懒汉式
  //优点 没有线程安全问题，但是类加载就创建对象，浪费空间
  private final static singleDemo instance = new singleDemo();
  private singleDemo(){};
  public static singleDemo getInstance(){
    return instance;
  }
}
```

```java
public class singleDemo{
    //双重检查懒汉式
    //volatile防止指令重排
    private volatile static singleDemo instance;
    private singleDemo(){};
    public static singleDemo getInstance(){
        if (instance == null){
            synchronized (singleDemo.class){
                //两个线程都走到这时，一个创建完释放锁后防止另一个也创建
                if (instance == null){
                    instance = new singleDemo();
                }
            }
        }
        return instance;
    }
}
```

# 数据库

### MySQL 架构中的三层服务是什么？

> 1.客户端层（连接层）：客户端层是与用户交互的部分，响应请求等，常见的客户端如Navicat、命令行
>
> 2.服务器层：负责接收客户端的请求，解析SQL语句，执行数据库操作，并将结果返回给客户端
>
> 3.存储引擎层：存储引擎层负责数据的存储和管理，是MySQL中数据的物理存储方式

### mysql集群如何搭建，各节点如何通信

> 第一步：在主库中，如果有数据更新，则主库会将数据的事务操作DML记录到二进制日志binary log中（在配置文件中log-bin指定的文件就是日志文件）。
> 第二步：从库会监听主库的binary log日志文件变化，当发生数据变化后，会将主库的日志文件拷贝到它的中继日志（relay log）中，放在末端。I/O线程会不断的去请求主库的bin-log日志，并将日志写入到relay log中，此时主库会生成一个log dump线程，用来给从库I/O线程传输bin-log日志文件。而且会将读取到的Master端的bin-log的文件名和位置记录到master-info文件中，以便在下一次读取的时候能够清楚的告诉Master “我需要从某个bin- log的哪个位置开始往后的日志内容，请发给我”。
> 第三步：从库会更新relay log文件中的操作，将数据的改变在从库中进行数据重演（即SQL线程执行操作，将日志文件中的记录变为数据操作行为再次执行，以达到主从数据最终一致性的目的）。

### 为什么不能使用自增ID或UUID做主键

> 1.存储空间占的更多
>
> 2.由于随机可能索引没有顺序性，导致索引效率低，树深度增加
>
> 3.难以读取和调试

# MQ

### 如果消息队列因为服务器或者网络原因挂了，怎么处理

> 开启消息队列的持久化

### 消息丢了/一致性问题

> [消息队列把消息弄丢了怎么办？-腾讯云开发者社区-腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/1823719)
>
> 1.生产者确认、MQ确认机制
>
> 2.MQ持久化
>
> 3.消费者失败重试

### mq怎么保证消息的顺序性

> 保证一个queue对应一个consumer

### mq的幂等性是什么，如何消除幂等

> 任意多次执行所产生的影响均与一次执行的影响相同
>
> 1.添加版本号（唯一消息`ID`），但是存在业务侵入
>
> 2.利用数据库特性，建立去重表
>
> 3.结合业务逻辑本身判断

# Redis

### redis集群如何搭建，各节点如何通信

### redis集群如何实现负载均衡

### 如果热点数据落在redis的某个节点上导致负载均衡失效，该如何解决

> [只需七步，教你轻松解决Redis热点Key问题 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/624724087)
>
> 数据分片（哈希）、读写分离（降低单个节点负载）、缓存预热、限流、熔断

### redis集群如何保持数据一致性

> 

# 分布式

### 怎么解决分布式事务

> [遇到分布式事务，这四种方案可以让你眉开眼笑~ - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/678443715)
>
> 本地消息表+重试：将分布式事务拆分成本地事务，新建消息表，保证消息的消费和DB的消费在一个事务内
>
> seata的AT模式，事务提交后增加一个快照(undo log)，
>
> 一阶段提交和报告事务状态，二阶段提交并删除undolog或者回滚

### 

### 分布式锁的实现

> 1.利用redis的setnx并且需要用lua脚本保证原子性

# 高并发

### 高并发情况下如何优化系统（外部、系统、底层等多个角度）

> 